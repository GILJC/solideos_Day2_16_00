/**
 * PDF 리포트 생성 모듈
 * jsPDF + jsPDF-AutoTable로 상세 리포트 생성
 */

// ========== PDF 생성 메인 함수 ==========
async function generatePDF(dataHistory) {
    console.log('PDF 생성 시작');

    // PDF 모달 표시
    const modal = document.getElementById('pdfModal');
    modal.classList.add('active');

    try {
        // jsPDF 초기화
        const { jsPDF } = window.jspdf;
        const doc = new jsPDF();

        let currentProgress = 0;

        // 1. 표지 페이지
        updatePdfProgress('표지 생성 중...', 10);
        generateCoverPage(doc);
        doc.addPage();

        // 2. 요약 페이지
        updatePdfProgress('요약 페이지 생성 중...', 20);
        generateSummaryPage(doc, dataHistory);
        doc.addPage();

        // 3. 그래프 이미지 페이지들
        updatePdfProgress('CPU 그래프 생성 중...', 30);
        await generateChartPage(doc, 'CPU 사용률', 'cpuLineChart');
        doc.addPage();

        updatePdfProgress('CPU 코어 그래프 생성 중...', 40);
        await generateChartPage(doc, 'CPU 코어별 사용률', 'cpuCoresChart');
        doc.addPage();

        updatePdfProgress('메모리 그래프 생성 중...', 50);
        await generateChartPage(doc, '메모리 사용률 (도넛)', 'memDoughnutChart');
        doc.addPage();

        await generateChartPage(doc, '메모리 사용률 (시간)', 'memLineChart');
        doc.addPage();

        updatePdfProgress('디스크 그래프 생성 중...', 60);
        await generateChartPage(doc, '디스크 사용률', 'diskBarChart');
        doc.addPage();

        updatePdfProgress('네트워크 그래프 생성 중...', 70);
        await generateChartPage(doc, '네트워크 트래픽', 'networkChart');
        doc.addPage();

        updatePdfProgress('GPU 그래프 생성 중...', 80);
        await generateChartPage(doc, 'GPU 사용률', 'gpuGaugeChart');
        doc.addPage();

        // 4. 통계 페이지
        updatePdfProgress('통계 페이지 생성 중...', 90);
        generateStatisticsPage(doc, dataHistory);

        // PDF 저장
        updatePdfProgress('PDF 저장 중...', 95);
        const fileName = `system-monitor-report-${getFormattedDateTime()}.pdf`;
        doc.save(fileName);

        updatePdfProgress('완료!', 100);
        setTimeout(() => {
            modal.classList.remove('active');
        }, 1000);

        console.log('PDF 생성 완료:', fileName);

    } catch (error) {
        console.error('PDF 생성 오류:', error);
        alert('PDF 생성 중 오류가 발생했습니다: ' + error.message);
        modal.classList.remove('active');
    }
}

// ========== 1. 표지 페이지 ==========
function generateCoverPage(doc) {
    const pageWidth = doc.internal.pageSize.getWidth();
    const pageHeight = doc.internal.pageSize.getHeight();

    // 배경색 (선택사항)
    doc.setFillColor(30, 30, 30);
    doc.rect(0, 0, pageWidth, pageHeight, 'F');

    // 제목
    doc.setTextColor(255, 255, 255);
    doc.setFontSize(32);
    doc.setFont(undefined, 'bold');
    doc.text('System Resource', pageWidth / 2, 80, { align: 'center' });
    doc.text('Monitoring Report', pageWidth / 2, 100, { align: 'center' });

    // 구분선
    doc.setDrawColor(78, 205, 196);
    doc.setLineWidth(2);
    doc.line(40, 120, pageWidth - 40, 120);

    // 모니터링 정보
    doc.setTextColor(200, 200, 200);
    doc.setFontSize(14);
    doc.setFont(undefined, 'normal');

    const startTime = window.getMonitoringStartTime ? new Date(window.getMonitoringStartTime()) : new Date();
    const duration = window.getElapsedSeconds ? window.getElapsedSeconds() : 0;
    const endTime = new Date(startTime.getTime() + duration * 1000);

    doc.text(`Monitoring Start: ${formatDateTime(startTime)}`, pageWidth / 2, 150, { align: 'center' });
    doc.text(`Monitoring End: ${formatDateTime(endTime)}`, pageWidth / 2, 165, { align: 'center' });
    doc.text(`Duration: ${formatDuration(duration)}`, pageWidth / 2, 180, { align: 'center' });

    // 시스템 정보
    doc.setFontSize(12);
    doc.text('Generated by System Monitor Dashboard', pageWidth / 2, 220, { align: 'center' });
    doc.text(`Report Date: ${formatDateTime(new Date())}`, pageWidth / 2, 235, { align: 'center' });

    // 푸터
    doc.setFontSize(10);
    doc.setTextColor(150, 150, 150);
    doc.text('Confidential - Internal Use Only', pageWidth / 2, pageHeight - 20, { align: 'center' });
}

// ========== 2. 요약 페이지 ==========
function generateSummaryPage(doc, dataHistory) {
    doc.setTextColor(0, 0, 0);
    doc.setFontSize(20);
    doc.setFont(undefined, 'bold');
    doc.text('Summary Statistics', 20, 20);

    doc.setDrawColor(78, 205, 196);
    doc.setLineWidth(1);
    doc.line(20, 25, 190, 25);

    // 통계 계산
    const stats = calculateStatistics(dataHistory);

    // CPU 통계 테이블
    doc.setFontSize(14);
    doc.setFont(undefined, 'bold');
    doc.text('CPU Usage', 20, 40);

    doc.autoTable({
        startY: 45,
        head: [['Metric', 'Value']],
        body: [
            ['Average', `${stats.cpu.avg.toFixed(2)}%`],
            ['Maximum', `${stats.cpu.max.toFixed(2)}%`],
            ['Minimum', `${stats.cpu.min.toFixed(2)}%`],
            ['Standard Deviation', `${stats.cpu.std.toFixed(2)}%`]
        ],
        theme: 'grid',
        headStyles: { fillColor: [255, 107, 107] },
        margin: { left: 20 }
    });

    // 메모리 통계 테이블
    let lastY = doc.lastAutoTable.finalY + 15;
    doc.setFontSize(14);
    doc.setFont(undefined, 'bold');
    doc.text('Memory Usage', 20, lastY);

    doc.autoTable({
        startY: lastY + 5,
        head: [['Metric', 'Value']],
        body: [
            ['Average', `${stats.memory.avg.toFixed(2)}%`],
            ['Maximum', `${stats.memory.max.toFixed(2)}%`],
            ['Minimum', `${stats.memory.min.toFixed(2)}%`],
            ['Standard Deviation', `${stats.memory.std.toFixed(2)}%`]
        ],
        theme: 'grid',
        headStyles: { fillColor: [78, 205, 196] },
        margin: { left: 20 }
    });

    // 네트워크 통계 테이블
    lastY = doc.lastAutoTable.finalY + 15;
    doc.setFontSize(14);
    doc.setFont(undefined, 'bold');
    doc.text('Network Traffic', 20, lastY);

    doc.autoTable({
        startY: lastY + 5,
        head: [['Metric', 'Download (KB/s)', 'Upload (KB/s)']],
        body: [
            ['Average', stats.network.rx.avg.toFixed(2), stats.network.tx.avg.toFixed(2)],
            ['Maximum', stats.network.rx.max.toFixed(2), stats.network.tx.max.toFixed(2)],
            ['Minimum', stats.network.rx.min.toFixed(2), stats.network.tx.min.toFixed(2)]
        ],
        theme: 'grid',
        headStyles: { fillColor: [168, 230, 207] },
        margin: { left: 20 }
    });

    // GPU 통계 테이블 (데이터가 있는 경우)
    if (stats.gpu.avg > 0) {
        lastY = doc.lastAutoTable.finalY + 15;
        doc.setFontSize(14);
        doc.setFont(undefined, 'bold');
        doc.text('GPU Usage', 20, lastY);

        doc.autoTable({
            startY: lastY + 5,
            head: [['Metric', 'Value']],
            body: [
                ['Average', `${stats.gpu.avg.toFixed(2)}%`],
                ['Maximum', `${stats.gpu.max.toFixed(2)}%`],
                ['Minimum', `${stats.gpu.min.toFixed(2)}%`]
            ],
            theme: 'grid',
            headStyles: { fillColor: [255, 159, 243] },
            margin: { left: 20 }
        });
    }
}

// ========== 3. 차트 페이지 ==========
async function generateChartPage(doc, title, chartId) {
    doc.setTextColor(0, 0, 0);
    doc.setFontSize(18);
    doc.setFont(undefined, 'bold');
    doc.text(title, 20, 20);

    doc.setDrawColor(78, 205, 196);
    doc.setLineWidth(1);
    doc.line(20, 25, 190, 25);

    // 차트를 이미지로 변환
    const canvas = document.getElementById(chartId);
    if (canvas) {
        try {
            const imgData = canvas.toDataURL('image/png');
            const imgWidth = 170;
            const imgHeight = 100;
            doc.addImage(imgData, 'PNG', 20, 35, imgWidth, imgHeight);

            // 차트 설명 추가
            doc.setFontSize(10);
            doc.setFont(undefined, 'italic');
            doc.setTextColor(100, 100, 100);
            doc.text(`Chart captured at ${formatDateTime(new Date())}`, 20, 145);
        } catch (error) {
            console.error(`차트 이미지 변환 오류 (${chartId}):`, error);
            doc.setFontSize(12);
            doc.setTextColor(255, 0, 0);
            doc.text('Chart image could not be generated.', 20, 50);
        }
    } else {
        doc.setFontSize(12);
        doc.setTextColor(255, 0, 0);
        doc.text('Chart not found.', 20, 50);
    }
}

// ========== 4. 통계 페이지 ==========
function generateStatisticsPage(doc, dataHistory) {
    doc.setTextColor(0, 0, 0);
    doc.setFontSize(20);
    doc.setFont(undefined, 'bold');
    doc.text('Detailed Statistics', 20, 20);

    doc.setDrawColor(78, 205, 196);
    doc.setLineWidth(1);
    doc.line(20, 25, 190, 25);

    // 데이터 포인트 정보
    doc.setFontSize(12);
    doc.setFont(undefined, 'normal');
    doc.text(`Total Data Points: ${dataHistory.timestamps.length}`, 20, 40);
    doc.text(`Monitoring Duration: ${formatDuration(window.getElapsedSeconds ? window.getElapsedSeconds() : 0)}`, 20, 50);

    // 상세 통계 테이블
    const stats = calculateStatistics(dataHistory);

    doc.autoTable({
        startY: 60,
        head: [['Resource', 'Average', 'Max', 'Min', 'Std Dev']],
        body: [
            ['CPU (%)', stats.cpu.avg.toFixed(2), stats.cpu.max.toFixed(2), stats.cpu.min.toFixed(2), stats.cpu.std.toFixed(2)],
            ['Memory (%)', stats.memory.avg.toFixed(2), stats.memory.max.toFixed(2), stats.memory.min.toFixed(2), stats.memory.std.toFixed(2)],
            ['Download (KB/s)', stats.network.rx.avg.toFixed(2), stats.network.rx.max.toFixed(2), stats.network.rx.min.toFixed(2), '-'],
            ['Upload (KB/s)', stats.network.tx.avg.toFixed(2), stats.network.tx.max.toFixed(2), stats.network.tx.min.toFixed(2), '-'],
            ['GPU (%)', stats.gpu.avg.toFixed(2), stats.gpu.max.toFixed(2), stats.gpu.min.toFixed(2), '-']
        ],
        theme: 'striped',
        headStyles: { fillColor: [78, 205, 196] },
        margin: { left: 20, right: 20 }
    });

    // 분석 및 권장사항
    const lastY = doc.lastAutoTable.finalY + 15;
    doc.setFontSize(14);
    doc.setFont(undefined, 'bold');
    doc.text('Analysis & Recommendations', 20, lastY);

    doc.setFontSize(11);
    doc.setFont(undefined, 'normal');
    let currentY = lastY + 10;

    // CPU 분석
    if (stats.cpu.avg > 80) {
        doc.setTextColor(255, 0, 0);
        doc.text('• High CPU usage detected. Consider optimizing processes.', 25, currentY);
        currentY += 8;
    } else if (stats.cpu.avg > 50) {
        doc.setTextColor(255, 165, 0);
        doc.text('• Moderate CPU usage. Monitor for performance issues.', 25, currentY);
        currentY += 8;
    } else {
        doc.setTextColor(0, 128, 0);
        doc.text('• CPU usage is within normal range.', 25, currentY);
        currentY += 8;
    }

    // 메모리 분석
    if (stats.memory.avg > 85) {
        doc.setTextColor(255, 0, 0);
        doc.text('• High memory usage. Consider closing unused applications.', 25, currentY);
        currentY += 8;
    } else if (stats.memory.avg > 70) {
        doc.setTextColor(255, 165, 0);
        doc.text('• Moderate memory usage. Keep an eye on memory-intensive tasks.', 25, currentY);
        currentY += 8;
    } else {
        doc.setTextColor(0, 128, 0);
        doc.text('• Memory usage is within normal range.', 25, currentY);
        currentY += 8;
    }

    // 네트워크 분석
    doc.setTextColor(0, 0, 0);
    const totalNetworkMB = (stats.network.rx.total + stats.network.tx.total) / 1024;
    doc.text(`• Total network transfer: ${totalNetworkMB.toFixed(2)} MB`, 25, currentY);
}

// ========== 통계 계산 함수 ==========
function calculateStatistics(dataHistory) {
    const calculateStats = (arr) => {
        if (!arr || arr.length === 0) return { avg: 0, max: 0, min: 0, std: 0, total: 0 };

        const sum = arr.reduce((a, b) => a + b, 0);
        const avg = sum / arr.length;
        const max = Math.max(...arr);
        const min = Math.min(...arr);

        // 표준편차 계산
        const squareDiffs = arr.map(value => Math.pow(value - avg, 2));
        const avgSquareDiff = squareDiffs.reduce((a, b) => a + b, 0) / arr.length;
        const std = Math.sqrt(avgSquareDiff);

        return { avg, max, min, std, total: sum };
    };

    return {
        cpu: calculateStats(dataHistory.cpu),
        memory: calculateStats(dataHistory.memory),
        network: {
            rx: calculateStats(dataHistory.network.rx),
            tx: calculateStats(dataHistory.network.tx)
        },
        gpu: calculateStats(dataHistory.gpu)
    };
}

// ========== PDF 진행률 업데이트 ==========
function updatePdfProgress(text, percent) {
    document.getElementById('pdfProgressText').textContent = text;
    document.getElementById('pdfProgressPercent').textContent = `${percent}%`;
    document.getElementById('pdfProgressBar').style.width = `${percent}%`;
}

// ========== 유틸리티 함수 ==========
function formatDateTime(date) {
    return date.toLocaleString('ko-KR', {
        year: 'numeric',
        month: '2-digit',
        day: '2-digit',
        hour: '2-digit',
        minute: '2-digit',
        second: '2-digit'
    });
}

function getFormattedDateTime() {
    const now = new Date();
    const year = now.getFullYear();
    const month = String(now.getMonth() + 1).padStart(2, '0');
    const day = String(now.getDate()).padStart(2, '0');
    const hour = String(now.getHours()).padStart(2, '0');
    const minute = String(now.getMinutes()).padStart(2, '0');
    const second = String(now.getSeconds()).padStart(2, '0');
    return `${year}${month}${day}-${hour}${minute}${second}`;
}

function formatDuration(seconds) {
    const minutes = Math.floor(seconds / 60);
    const secs = seconds % 60;
    return `${minutes}분 ${secs}초`;
}

// ========== 전역 함수 노출 ==========
window.generatePDF = generatePDF;
